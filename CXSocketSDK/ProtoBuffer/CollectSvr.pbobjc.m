// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CollectSvr.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "CollectSvr.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - CollectSvrRoot

@implementation CollectSvrRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - CollectSvrRoot_FileDescriptor

static GPBFileDescriptor *CollectSvrRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum Client

GPBEnumDescriptor *Client_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Phone\000Car\000";
    static const int32_t values[] = {
        Client_Phone,
        Client_Car,
    };
    static const char *extraTextFormatInfo = "\002\000%\000\001#\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Client)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Client_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Client_IsValidValue(int32_t value__) {
  switch (value__) {
    case Client_Phone:
    case Client_Car:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum LoginErrorCode

GPBEnumDescriptor *LoginErrorCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000ErrorClose\000ErrorRetry\000";
    static const int32_t values[] = {
        LoginErrorCode_Success,
        LoginErrorCode_ErrorClose,
        LoginErrorCode_ErrorRetry,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(LoginErrorCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:LoginErrorCode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL LoginErrorCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case LoginErrorCode_Success:
    case LoginErrorCode_ErrorClose:
    case LoginErrorCode_ErrorRetry:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CoordinateType

GPBEnumDescriptor *CoordinateType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Gcj\000BaiduCoordinate\000SosoGcjCoordinate\000Wg"
        "s84\000";
    static const int32_t values[] = {
        CoordinateType_Gcj,
        CoordinateType_BaiduCoordinate,
        CoordinateType_SosoGcjCoordinate,
        CoordinateType_Wgs84,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CoordinateType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CoordinateType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CoordinateType_IsValidValue(int32_t value__) {
  switch (value__) {
    case CoordinateType_Gcj:
    case CoordinateType_BaiduCoordinate:
    case CoordinateType_SosoGcjCoordinate:
    case CoordinateType_Wgs84:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum MessageType

GPBEnumDescriptor *MessageType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Ping\000Pong\000LoginRequest\000LoginResponse\000Pus"
        "hMessageResponse\000GatewayPush\000Ok\000Ack\000Serv"
        "erLoginRequest\000SeverLoginResponse\000Server"
        "Message\000CoordinatePull\000Closechannel\000User"
        "info\000Userinforesponse\000PushMessageRequest"
        "\000UpstreamMessage\000ClientMessage\000";
    static const int32_t values[] = {
        MessageType_Ping,
        MessageType_Pong,
        MessageType_LoginRequest,
        MessageType_LoginResponse,
        MessageType_PushMessageResponse,
        MessageType_GatewayPush,
        MessageType_Ok,
        MessageType_Ack,
        MessageType_ServerLoginRequest,
        MessageType_SeverLoginResponse,
        MessageType_ServerMessage,
        MessageType_CoordinatePull,
        MessageType_Closechannel,
        MessageType_Userinfo,
        MessageType_Userinforesponse,
        MessageType_PushMessageRequest,
        MessageType_UpstreamMessage,
        MessageType_ClientMessage,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MessageType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MessageType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MessageType_IsValidValue(int32_t value__) {
  switch (value__) {
    case MessageType_Ping:
    case MessageType_Pong:
    case MessageType_LoginRequest:
    case MessageType_LoginResponse:
    case MessageType_PushMessageResponse:
    case MessageType_GatewayPush:
    case MessageType_Ok:
    case MessageType_Ack:
    case MessageType_ServerLoginRequest:
    case MessageType_SeverLoginResponse:
    case MessageType_ServerMessage:
    case MessageType_CoordinatePull:
    case MessageType_Closechannel:
    case MessageType_Userinfo:
    case MessageType_Userinforesponse:
    case MessageType_PushMessageRequest:
    case MessageType_UpstreamMessage:
    case MessageType_ClientMessage:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CloseChannelReason

GPBEnumDescriptor *CloseChannelReason_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Wrongtoken\000Otherlogin\000";
    static const int32_t values[] = {
        CloseChannelReason_Wrongtoken,
        CloseChannelReason_Otherlogin,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CloseChannelReason)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CloseChannelReason_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CloseChannelReason_IsValidValue(int32_t value__) {
  switch (value__) {
    case CloseChannelReason_Wrongtoken:
    case CloseChannelReason_Otherlogin:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum OS

GPBEnumDescriptor *OS_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Android\000Ios\000";
    static const int32_t values[] = {
        OS_Android,
        OS_Ios,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(OS)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:OS_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL OS_IsValidValue(int32_t value__) {
  switch (value__) {
    case OS_Android:
    case OS_Ios:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - CollectMessage

@implementation CollectMessage

@dynamic messageType;
@dynamic data_p;

typedef struct CollectMessage__storage_ {
  uint32_t _has_storage_[1];
  MessageType messageType;
  NSData *data_p;
} CollectMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageType",
        .dataTypeSpecific.enumDescFunc = MessageType_EnumDescriptor,
        .number = CollectMessage_FieldNumber_MessageType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CollectMessage__storage_, messageType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = CollectMessage_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CollectMessage__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CollectMessage class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CollectMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CollectMessage_MessageType_RawValue(CollectMessage *message) {
  GPBDescriptor *descriptor = [CollectMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CollectMessage_FieldNumber_MessageType];
  return GPBGetMessageInt32Field(message, field);
}

void SetCollectMessage_MessageType_RawValue(CollectMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [CollectMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CollectMessage_FieldNumber_MessageType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ServerLoginRequest

@implementation ServerLoginRequest

@dynamic key;

typedef struct ServerLoginRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
} ServerLoginRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = ServerLoginRequest_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServerLoginRequest__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServerLoginRequest class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServerLoginRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServerLoginRespone

@implementation ServerLoginRespone

@dynamic key;
@dynamic channelId;
@dynamic ip;

typedef struct ServerLoginRespone__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *channelId;
  NSString *ip;
} ServerLoginRespone__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = ServerLoginRespone_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServerLoginRespone__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = ServerLoginRespone_FieldNumber_ChannelId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ServerLoginRespone__storage_, channelId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = ServerLoginRespone_FieldNumber_Ip,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ServerLoginRespone__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServerLoginRespone class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServerLoginRespone__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServerMessage

@implementation ServerMessage

@dynamic userid;
@dynamic content;
@dynamic serverId;
@dynamic seqid;
@dynamic retType;
@dynamic client;

typedef struct ServerMessage__storage_ {
  uint32_t _has_storage_[1];
  Client client;
  NSString *userid;
  NSString *content;
  NSString *serverId;
  int64_t seqid;
} ServerMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userid",
        .dataTypeSpecific.className = NULL,
        .number = ServerMessage_FieldNumber_Userid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServerMessage__storage_, userid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = ServerMessage_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ServerMessage__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serverId",
        .dataTypeSpecific.className = NULL,
        .number = ServerMessage_FieldNumber_ServerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ServerMessage__storage_, serverId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "seqid",
        .dataTypeSpecific.className = NULL,
        .number = ServerMessage_FieldNumber_Seqid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ServerMessage__storage_, seqid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "retType",
        .dataTypeSpecific.className = NULL,
        .number = ServerMessage_FieldNumber_RetType,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "client",
        .dataTypeSpecific.enumDescFunc = Client_EnumDescriptor,
        .number = ServerMessage_FieldNumber_Client,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ServerMessage__storage_, client),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServerMessage class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServerMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\010\000\005\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ServerMessage_Client_RawValue(ServerMessage *message) {
  GPBDescriptor *descriptor = [ServerMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ServerMessage_FieldNumber_Client];
  return GPBGetMessageInt32Field(message, field);
}

void SetServerMessage_Client_RawValue(ServerMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [ServerMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ServerMessage_FieldNumber_Client];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - LoginRequest

@implementation LoginRequest

@dynamic userId;
@dynamic phone;
@dynamic token;
@dynamic version;
@dynamic sign;
@dynamic client;

typedef struct LoginRequest__storage_ {
  uint32_t _has_storage_[1];
  Client client;
  NSString *userId;
  NSString *phone;
  NSString *token;
  NSString *version;
  NSString *sign;
} LoginRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = LoginRequest_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LoginRequest__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phone",
        .dataTypeSpecific.className = NULL,
        .number = LoginRequest_FieldNumber_Phone,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LoginRequest__storage_, phone),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = LoginRequest_FieldNumber_Token,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LoginRequest__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = LoginRequest_FieldNumber_Version,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LoginRequest__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = LoginRequest_FieldNumber_Sign,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LoginRequest__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "client",
        .dataTypeSpecific.enumDescFunc = Client_EnumDescriptor,
        .number = LoginRequest_FieldNumber_Client,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LoginRequest__storage_, client),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginRequest class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LoginRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t LoginRequest_Client_RawValue(LoginRequest *message) {
  GPBDescriptor *descriptor = [LoginRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LoginRequest_FieldNumber_Client];
  return GPBGetMessageInt32Field(message, field);
}

void SetLoginRequest_Client_RawValue(LoginRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [LoginRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LoginRequest_FieldNumber_Client];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - LoginResponse

@implementation LoginResponse

@dynamic userId;
@dynamic key;
@dynamic errorCode;

typedef struct LoginResponse__storage_ {
  uint32_t _has_storage_[1];
  LoginErrorCode errorCode;
  NSString *userId;
  NSString *key;
} LoginResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = LoginResponse_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LoginResponse__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = LoginResponse_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LoginResponse__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "errorCode",
        .dataTypeSpecific.enumDescFunc = LoginErrorCode_EnumDescriptor,
        .number = LoginResponse_FieldNumber_ErrorCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LoginResponse__storage_, errorCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginResponse class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LoginResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t LoginResponse_ErrorCode_RawValue(LoginResponse *message) {
  GPBDescriptor *descriptor = [LoginResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LoginResponse_FieldNumber_ErrorCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetLoginResponse_ErrorCode_RawValue(LoginResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [LoginResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LoginResponse_FieldNumber_ErrorCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PushMessageResponse

@implementation PushMessageResponse

@dynamic content;
@dynamic timestamp;
@dynamic seqId;
@dynamic serverId;
@dynamic retType;

typedef struct PushMessageResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
  NSString *serverId;
  int64_t timestamp;
  int64_t seqId;
} PushMessageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = PushMessageResponse_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushMessageResponse__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PushMessageResponse_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushMessageResponse__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "seqId",
        .dataTypeSpecific.className = NULL,
        .number = PushMessageResponse_FieldNumber_SeqId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PushMessageResponse__storage_, seqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "serverId",
        .dataTypeSpecific.className = NULL,
        .number = PushMessageResponse_FieldNumber_ServerId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PushMessageResponse__storage_, serverId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "retType",
        .dataTypeSpecific.className = NULL,
        .number = PushMessageResponse_FieldNumber_RetType,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushMessageResponse class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushMessageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\005\000\004\010\000\005\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushMessageRequest

@implementation PushMessageRequest

@dynamic seqId;
@dynamic serverId;
@dynamic timestamp;

typedef struct PushMessageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *serverId;
  int64_t seqId;
  int64_t timestamp;
} PushMessageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seqId",
        .dataTypeSpecific.className = NULL,
        .number = PushMessageRequest_FieldNumber_SeqId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushMessageRequest__storage_, seqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "serverId",
        .dataTypeSpecific.className = NULL,
        .number = PushMessageRequest_FieldNumber_ServerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushMessageRequest__storage_, serverId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = PushMessageRequest_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PushMessageRequest__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushMessageRequest class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushMessageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\005\000\002\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PingMessage

@implementation PingMessage

@dynamic seqId;

typedef struct PingMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t seqId;
} PingMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seqId",
        .dataTypeSpecific.className = NULL,
        .number = PingMessage_FieldNumber_SeqId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PingMessage__storage_, seqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PingMessage class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PingMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PongMessage

@implementation PongMessage

@dynamic seqId;

typedef struct PongMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t seqId;
} PongMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seqId",
        .dataTypeSpecific.className = NULL,
        .number = PongMessage_FieldNumber_SeqId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PongMessage__storage_, seqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PongMessage class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PongMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfoMessage

@implementation UserInfoMessage

@dynamic userId;
@dynamic deviceType;
@dynamic nettype;
@dynamic model;
@dynamic manufacturer;
@dynamic brand;
@dynamic appVersion;
@dynamic version;
@dynamic client;

typedef struct UserInfoMessage__storage_ {
  uint32_t _has_storage_[1];
  OS deviceType;
  Client client;
  NSString *userId;
  NSString *nettype;
  NSString *model;
  NSString *manufacturer;
  NSString *brand;
  NSString *appVersion;
  NSString *version;
} UserInfoMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoMessage_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfoMessage__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.enumDescFunc = OS_EnumDescriptor,
        .number = UserInfoMessage_FieldNumber_DeviceType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserInfoMessage__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "nettype",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoMessage_FieldNumber_Nettype,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserInfoMessage__storage_, nettype),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "model",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoMessage_FieldNumber_Model,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserInfoMessage__storage_, model),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "manufacturer",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoMessage_FieldNumber_Manufacturer,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserInfoMessage__storage_, manufacturer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "brand",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoMessage_FieldNumber_Brand,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserInfoMessage__storage_, brand),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appVersion",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoMessage_FieldNumber_AppVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UserInfoMessage__storage_, appVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoMessage_FieldNumber_Version,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UserInfoMessage__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "client",
        .dataTypeSpecific.enumDescFunc = Client_EnumDescriptor,
        .number = UserInfoMessage_FieldNumber_Client,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UserInfoMessage__storage_, client),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserInfoMessage class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfoMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\006\000\002\n\000\007\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t UserInfoMessage_DeviceType_RawValue(UserInfoMessage *message) {
  GPBDescriptor *descriptor = [UserInfoMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserInfoMessage_FieldNumber_DeviceType];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserInfoMessage_DeviceType_RawValue(UserInfoMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UserInfoMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserInfoMessage_FieldNumber_DeviceType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t UserInfoMessage_Client_RawValue(UserInfoMessage *message) {
  GPBDescriptor *descriptor = [UserInfoMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserInfoMessage_FieldNumber_Client];
  return GPBGetMessageInt32Field(message, field);
}

void SetUserInfoMessage_Client_RawValue(UserInfoMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [UserInfoMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:UserInfoMessage_FieldNumber_Client];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - UserInfoResponse

@implementation UserInfoResponse

@dynamic result;

typedef struct UserInfoResponse__storage_ {
  uint32_t _has_storage_[1];
} UserInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserInfoResponse class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CoordinateRequest

@implementation CoordinateRequest

@dynamic timestamp;
@dynamic lat;
@dynamic lon;
@dynamic type;
@dynamic provider;
@dynamic course;
@dynamic speed;

typedef struct CoordinateRequest__storage_ {
  uint32_t _has_storage_[1];
  CoordinateType type;
  int32_t provider;
  int64_t timestamp;
  double lat;
  double lon;
  double course;
  double speed;
} CoordinateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = CoordinateRequest_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CoordinateRequest__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lat",
        .dataTypeSpecific.className = NULL,
        .number = CoordinateRequest_FieldNumber_Lat,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CoordinateRequest__storage_, lat),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "lon",
        .dataTypeSpecific.className = NULL,
        .number = CoordinateRequest_FieldNumber_Lon,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CoordinateRequest__storage_, lon),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = CoordinateType_EnumDescriptor,
        .number = CoordinateRequest_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CoordinateRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "provider",
        .dataTypeSpecific.className = NULL,
        .number = CoordinateRequest_FieldNumber_Provider,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CoordinateRequest__storage_, provider),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "course",
        .dataTypeSpecific.className = NULL,
        .number = CoordinateRequest_FieldNumber_Course,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CoordinateRequest__storage_, course),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "speed",
        .dataTypeSpecific.className = NULL,
        .number = CoordinateRequest_FieldNumber_Speed,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CoordinateRequest__storage_, speed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CoordinateRequest class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CoordinateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CoordinateRequest_Type_RawValue(CoordinateRequest *message) {
  GPBDescriptor *descriptor = [CoordinateRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CoordinateRequest_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetCoordinateRequest_Type_RawValue(CoordinateRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [CoordinateRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CoordinateRequest_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - CoordinatePackageRequest

@implementation CoordinatePackageRequest

@dynamic timestamp;
@dynamic userId;
@dynamic coordinateArray, coordinateArray_Count;
@dynamic cityId;
@dynamic adCode;

typedef struct CoordinatePackageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSMutableArray *coordinateArray;
  NSString *cityId;
  NSString *adCode;
  uint64_t timestamp;
} CoordinatePackageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = CoordinatePackageRequest_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CoordinatePackageRequest__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = CoordinatePackageRequest_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CoordinatePackageRequest__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coordinateArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CoordinateRequest),
        .number = CoordinatePackageRequest_FieldNumber_CoordinateArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CoordinatePackageRequest__storage_, coordinateArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cityId",
        .dataTypeSpecific.className = NULL,
        .number = CoordinatePackageRequest_FieldNumber_CityId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CoordinatePackageRequest__storage_, cityId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adCode",
        .dataTypeSpecific.className = NULL,
        .number = CoordinatePackageRequest_FieldNumber_AdCode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CoordinatePackageRequest__storage_, adCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CoordinatePackageRequest class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CoordinatePackageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\002\006\000\004\006\000\005\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CloseChannel

@implementation CloseChannel

@dynamic errorMessage;
@dynamic userId;
@dynamic timeStamp;
@dynamic reason;

typedef struct CloseChannel__storage_ {
  uint32_t _has_storage_[1];
  CloseChannelReason reason;
  NSString *errorMessage;
  NSString *userId;
  uint64_t timeStamp;
} CloseChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "errorMessage",
        .dataTypeSpecific.className = NULL,
        .number = CloseChannel_FieldNumber_ErrorMessage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CloseChannel__storage_, errorMessage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = CloseChannel_FieldNumber_UserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CloseChannel__storage_, userId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = CloseChannel_FieldNumber_TimeStamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CloseChannel__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "reason",
        .dataTypeSpecific.enumDescFunc = CloseChannelReason_EnumDescriptor,
        .number = CloseChannel_FieldNumber_Reason,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CloseChannel__storage_, reason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CloseChannel class]
                                     rootClass:[CollectSvrRoot class]
                                          file:CollectSvrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CloseChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\014\000\002\006\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t CloseChannel_Reason_RawValue(CloseChannel *message) {
  GPBDescriptor *descriptor = [CloseChannel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CloseChannel_FieldNumber_Reason];
  return GPBGetMessageInt32Field(message, field);
}

void SetCloseChannel_Reason_RawValue(CloseChannel *message, int32_t value) {
  GPBDescriptor *descriptor = [CloseChannel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:CloseChannel_FieldNumber_Reason];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
